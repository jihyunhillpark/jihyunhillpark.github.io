---
layout: post
title: "TIL - 2021.01.25"
author: jihyunhill
categories: TIL(Today-I-Learned)
tags: TIL Java 상속
---

사실 이번 올리는 TIL은 오늘 하루 동안 다 했다기 보다는 이틀에 걸쳐서 한 것을 적었다.    

#### 1. Inheritance     
자바의 상속개념을 배웠다. 상속은 Java의 3대(상속, 다형성, 캡슐화) 특징 중 하나로 매우매우 중요한 개념이다.

상속이란 부모로부터 물려받은 내용의 일부를 수정하거나 __확장__ 하는 것이다.     
상속은 다시 __클래스 상속__ 과 __인터페이스 상속__ 으로 나뉘는데, 핵심원리를 알면 둘이 사용할 때가 다른 것이 명확해진다. 클래스는 다시 추상클래스와 구현클래스(concrete class?)로 나뉘는데 나중에 블로그에 자세하게 포스팅할 기회가 있으면 해야겠다. 아무튼 가장 중요한 것은 인터페이스와 클래스중 어느 것을 만들어  자식으로 상속시키게 할 것인가가 중요한데 두 가지만 기억하자. 인터페이스는 기능을 물려받지 않고, 클래스는 구체적인 기능을 물려받는 것.     

인터페이스는 약속이라고 생각하면 편하다. 예를 들어, 자동차들은 반드시 주행기능을 가진다. 하지만 현대그룹에서 만든 차와 테슬라에서 만든 차의 주행 기능은 완전히 다르다. 비록 자동차 회사마다 구현하는 주행기술은 다 다르지만, 모든 자동차들이 주행기능을 가져야한다는 것을 약속이다. (안그러면 큰일난다!!) 이 개념으 자바에 고대로 적용하면된다. 자동차 인터페이스를 만들어 이 인터페이스를 구현하는 모든 구체적인 자동차들은 자동차 인터페이스에 명시된 기능 (즉, 약속)을 구현해야만 한다.

한편 클래스는 기존의 것을 확장하는 것이 목적이라고 보면 편하다. 클래스는 인터페이스와는 다르게 자식에게 이미 구현된 메소드와 상태들을 상속시킬 수 있다. 만약 부모 클래스를 상속받는 자식들이 모두 구체적인 공통 기능 혹은 상태(속성)를 가지고 있다면, 자식마다 각각 그 기능이나 상태를 가지기 보다는 차라리 부모에서 정의하고 상속만 받아온다면 번거로움을 덜 수 있지 않을까? 예를 들어 동물과 원숭이, 인간, 코알라를 생각해보자. 동물은 나머지 세 종을 포괄하는 상위 개념이다. 그런데 세 종은 모두 생명체라는 속성과 심장이 뛰는 기능이 있다. 이에 종마다 공통적으로 가지는 심장이 뛰는 기능과 생명체라는 속성을 개별로 구현하지 말고, 동물이라는 공통 클래스(부모 클래스)를 만들어 확장(상속)시키면 세분화된 종으로 나아갈 수 있다. 이로써 번거로운 작업을 줄여 개발 시간 및 비용을 줄일 수 있다.


*자바에서는 크게 세 가지의 관계(is-a, has-a, use-a )가 있다. 여기서 상속은 is-a관계가 성립시킨다. 예를들어 "원숭이는 동물이다."(Monkey is an animal)이라는 관계가 성립하고, 이를 클래스로 나타낸다면 Monkey가 animal을 상속하는 구조로 설계할 수 있다.     


#### 2. DP문제(RGB거리) 풀기__    

RGB거리를 구하는 문제는 백준 알고리즘 사이트에 나온 문제이다. 개념은 알고 있으나 DP를 많이 풀어본 경험이 없어서, 어떻게 이문제를 DP로 풀지를 두고 깊은 고민을 했다.       

처음 내가 선택한 전략은 n-1번째 집에서 n번쨰 집으로 넘어갈 때 마다 __첫 번째 집에서 n-1번째 집까지 이미 구해서 저장한 rgb 거리의 최솟값을 이용하여__ n번 째 집까지의 최소 rgb거리를 구하는 것이었다. 정말 "DP로만 풀어야지"만 집중하여 문제를 풀고자 했던 것이다.       

이렇게 풀게되면 문제점이 뭘까? 그렇다. 각 집의 새로운 n집의 rgb 거리값의 따라서 아예 첫 번째 집부터 시작하여 구하는 조합이 달라질 수 있다는 것이다. 가령,     
r  g  b      
10 13 21         
15 17 20     
4  99 50         
의 경우가 있다.     

계속 이 생각에 꽂혀서 사고가 편협하게 되었을까. 결국 다른 블로그에서 아이디어를 얻었다. 다양한 블로그들을 본 결과 다음과 같은 접근을 할 수 있었다. n번 째 집에서 R, G, B 중 하나를 선택했을 때, n-1에서 선택할 수 있는 최솟값을 R,G,B 모든 경우에서 구하는 것이었다. 이렇게 생각하면 편하겠다. __"내가 R을 선택한다면 이전 집이 B와 G중 어느 것을 칠해야 거리가 최소가 될까?"__     

#### 3. 주변탐색 문제 풀기__     

빌딩과 공원으로 이루어진 도시를 탐색하는 문제를 풀었다. 이처럼 2차원 배열 탐색 문제 중, 각 요소마다 그 주변을 탐색해야 할 때가 있다. 예를 들어서 좌,우,상,하의 요소들의 값을 확인해야하는 4방탐색이 있을 수 있고, 여기에 추가로 왼쪽 위 대각선, 오른쪽 위 대각선, 왼쪽 밑 대각선, 오른쪽 밑 대각선 등을 한 요소의 8개의 방향으로 주변을 탐색해야 할 수도 있다. 이번 문제를 풀면서, 주변 탐색문제를 풀 때 염두에 두어야 할 두 가지를 알 수 있었다.     

__하나는, 전체 배열의 경계면들을 새로운 배열로 둘러 탐색할 것인지, 아니면 각 경계면 케이스(ex. 2차원배열의 가장 윗 경계면, 왼쪽 경계면 등..)별로 나누어 처리하고 탐색할 것인지를 정해야 한다__ 는 것이고     

__두 번쨰는. (좌표개념을 도입해) 각 방향으로 이동하는 변화값 dx, dy를 나타내는 틀(=배열) 이용하면 간결하고 일반화된 코드를 짤 수 있다는 것이다.__       
