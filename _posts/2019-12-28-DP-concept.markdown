---
layout: post
title:  "DP(Dynamic Programming)동적계획법"
date:   2019-12-28 05:33:59
author: Jihyunhill
categories: Algorithms
tags:	Algorithms coding test 종만북
---

# DP란 무엇인가?
DP는 Dynamic Programming이라는 뜻으로 한국어로 번역하면 '동적 계획법'이다.
(간혹 동적 프로그래밍이라고 하나 사실상 동적 계획법이 맞는 표현이며, 엄연히 다른 것이다.) 동적계획법 분할 정복(Divide & Conquer)과 같은 접근 방식을 취한다. 동적 계획법 역시 주어진 문제를 더 작은 문제들로 쪼갠 뒤, 그 작은 문제들(sub problem)을 해결/계산하고, 이 답들로부터 원래 주어진 문제에 대한 답을 도출해 내기 때문이다.          

## 그럼 분할정복과 DP는 뭐가 다른건데?
두 알고리즘의 차이점은 __문제를 나누는 방식__ 이다.      

__분할 정복__ : 주어진 문제의 부분 문제들 사이에 서로 상관 관계가 없는 경우 사용하기 적절하다. 즉 부분문제가 한번만 사용될 때 적합하다.   

__동적 계획법__ : 문제를 풀기 위해 부분 문제를 푼다고 앞에서 말했다. 그런데 이 부분 문제가 두 개 이상의 문제를 푸는데 사용될 수 된다면?(예를 들어서 피보나치 함수 5항을 구하기 위해서 2항을 3번이나 사용하게 된다. 이는 4항과 3항의 문제를 푸는 데에도 2항이 사용되기 때문이다. f(3)=f(2)+f(1),f(4)=f(3)+f(2)=f(2)+f(2)+f(1),f(5)=f(4)+f(3)=f(2)+f(2)+f(2)+f(1)) 이처럼 문제의 답을 구하기 위해 매번 새로이 중복해서 부분문제를 계산하는 대신, __한번만 계산하고 그 결과를 저장해 두고두고 사용하는__ 방법을 동적 계획법이라고 한다. 이렇게 하면 속도가 빨라진다!    


\*잠깐 용어 정리!
<font color="green">
캐시(cache) - 부분문제의 답을 저장하는 공간<br>
중복되는 부분 문제(overlapping subproblem) - 두 번 이상 계산되는 부분 문제<br>
메모이제이션(memoization) - 캐시를 마련하고, 부분 문제에 대한 함수의 결과를 캐시에 저장 하여 재활용하는 최적화 기법<br>
</font>     

유명한 동적 계획 문제 : 이항계수(파스칼의 삼각형 - nCr = n-1Cr-1 + n-1Cr), 피보나치, 최단경로       
\*이항계수랑 피보나치는 분할정복으로 풀 수 있긴 하다.     

## Top-Down vs Bottom-up
DP를 푸는 방법은 두가지가 있다. 하향식(Top-Down)접근 방식과 상향식(Bottom-Up)접근 방식이다.       

__하향식__ : 재귀(recursion)과 같은 방법으로 위에서 아래로 내려온다. 여기서 구별되는 점은 함수 사용을 줄이기 위해서 __메모이제이션(memoization)__ 을 이용한다.       

__상향식__ : for문을 이용해서 처읍 값부터 다음 값을 계산해 나가는 방법이다. 이 또한 메모이제이션을 이용하겠쥬?

## 메모이제이션 구현        
이제 본격적으로 메모이제이션을 구현할 때 어떤 점을 유의하여야 하는지 보자         
1. 저장공간 캐시(cache)을 초기화 한다.(1,0으로 참,거짓을 리턴하는 경우가 많아서 -1로 다 초기화 시키면 편하다ㅇ0ㅇ)  
2. 기저 사례를 제일 먼저 처리한다.(입력 범위를 벗어나거나, 마지막에 도착했을 경우)         
3. 캐시에 있는 값을 참조형 변수를 이용해서 반환하기       
  (가령, int &ret = cache[x][y];       
        ....       
        return ret;       
  이렇게 하면 인덱스 순서를 바꿔 쓰는 실수를 줄어주고, cache[x][y]에 매번 직접 답을 저장하지 않아도 되어서 귀찮음을 줄여준다. 음, 굳이 안해도 되는 부분이니 이해한 사람만)      

## 동적 계획법을 풀기 위해서는?      
처음 동적 계획법을 접했다면 무작정 동적계획법으로 풀기보다는, 먼저 우리에게 좀 더 친숙한(?) 재귀함수에 기반한 완전탐색을 생각해 보아야 한다. 먼저 완전탐색으로 푸는 방법을 생각하고, 이것을 바탕으로 중복된 부분 문제를 한 번만 계산하도록 메모이제이션을 사용하도록 한다.        

\*정리!     
1. 문제를 완전탐색으로 해결한다.    
2. 중복된 부분 문제를 한번만 계삭할 수 있게 메모이제이션을 적용한다.     
3. 별거 없다! 메모이제이션을 빼면 완전탐색이나 DP의 다른 부분은 거의 비슷하다!     
